# 対話的でない場合は何もしない
case $- in
    *i*) ;;
      *) return;;
esac

# 履歴に重複行やスペースで始まる行を記録しない
HISTCONTROL=ignoreboth

# 履歴ファイルに追記し、上書きしない
shopt -s histappend

# 履歴の長さは HISTSIZE と HISTFILESIZE で設定
HISTSIZE=1000
HISTFILESIZE=2000

# 各コマンド実行後にウィンドウサイズを確認し、必要なら LINES と COLUMNS を更新
shopt -s checkwinsize

# Gitディレクトリかどうか判定
is_git_repo() {
  git rev-parse --is-inside-work-tree >/dev/null 2>&1
}

# Gitのブランチ名を取得する
git_branch_name() {
  ! $(is_git_repo) && return
  local branch=$(git branch --show-current)
  echo " $branch"
}

# Gitのステータスを取得する
git_status() {
  ! $(is_git_repo) && return
  local status=""

  # 未ステージング変更あり (add可)
  # git status --porcelainで2文字目が空白以外の行がある
  # 詳細はgit status --helpでPorcelain Formatを参照
  if git status --porcelain 2>/dev/null | grep -q '^.[^[:space:]]'; then
    status+="+"
  fi

  # ステージング変更あり (commit可)
  # git status --porcelainで1文字目が空白または?以外の行がある
  # 詳細はgit status --helpでPorcelain Formatを参照
  if git status --porcelain 2>/dev/null | grep -q '^[^[:space:]|?]'; then
    status+="*"
  fi

  # push/pull 状態
  read pull push < <(git rev-list --left-right --count @{upstream}...HEAD 2>/dev/null || echo "0 0")
  if [ "$push" -gt 0 ]; then
    status+="↑$push"
  fi
  if [ "$pull" -gt 0 ]; then
    status+="↓$pull"
  fi

  # 出力
  if [ -n "$status" ]; then
    echo " [$status]"
  fi
}

# コマンド実行時間を測定
COMMAND_START_TIME=
command_timer_start() {
  COMMAND_START_TIME=$(date '+%s%3N')
}
command_timer_elapsed() {
  local elapsed=$(($(date '+%s%3N') - COMMAND_START_TIME))

  if (( elapsed < 1000 )); then
    echo " ${elapsed}ms"
  elif (( elapsed < 60000 )); then
    echo " $(( elapsed / 1000 )).$(( (elapsed % 1000) / 100 ))s"
  else
    echo " $(( elapsed / 60000 )).$(( (elapsed % 60000) / 6000 % 10 ))m"
  fi
}
trap 'command_timer_start' DEBUG

# ウィンドウタイトル設定
SET_TITLE='\[\e]0;\W\a\]'
# デザイン
COLOR_BOLD_RED='\[\e[1;31m\]'
COLOR_BOLD_GREEN='\[\e[1;32m\]'
COLOR_BOLD_YELLOW='\[\e[1;33m\]'
COLOR_BOLD_BLUE='\[\e[1;34m\]'
COLOR_BOLD_PURPLE='\[\e[1;35m\]'
COLOR_BOLD_LIGHT_BLUE='\[\e[1;36m\]'
COLOR_RESET='\[\e[00m\]'
# プロンプト設定
PS1="${SET_TITLE}\
${COLOR_BOLD_LIGHT_BLUE}\W\
${COLOR_RESET}\$(is_git_repo && echo ' on')\
${COLOR_BOLD_PURPLE}\$(git_branch_name)\
${COLOR_BOLD_RED}\$(git_status)\
${COLOR_RESET} took\
${COLOR_BOLD_YELLOW}\$(command_timer_elapsed)
${COLOR_RESET}\$ "

# ls のカラーサポートを有効化し、エイリアスを追加
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
fi

# プログラマブル補完機能を有効化
# /etc/bash.bashrc ですでに有効なら不要
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# 環境変数
export EDITOR=nvim
export LANG=ja_JP.UTF-8

# エイリアス
alias x="mise x --"
alias cw="x copilot --allow-tool 'write' --model claude-haiku-4.5"

# ローカル設定ファイルの読み込み
if [ -f ~/.bashrc.local ]; then
    source ~/.bashrc.local
fi
